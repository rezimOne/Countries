{"version":3,"file":"./src/index.js","mappings":";;;;;;;;;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;;;;;;;;;;;;;;;;ACHA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAFA;AAIA;AAAA;AAEA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AAFA;AAIA;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAAA;AAEA;AAEA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACpEA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;;AACA;AACA;AAAA;AAEA;AACA;AACA;;AACA;AACA;AAAA;AAEA;AACA;AACA;;AACA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AACA;;;;;;;;;;;;;;;;ACjCA;AACA;AAEA;AACA;AACA;AACA;AACA;;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AAHA;AAMA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;;;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAZA;AAaA;;;;;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AACA;;AACA;AAIA;AACA;AACA;;AACA;AAEA;AACA;AACA;;AACA;AAEA;AACA;AACA;;AACA;AAIA;AACA;AACA;;AACA;AACA","sources":["webpack://countries/./src/appVariables.ts","webpack://countries/./src/task1/task1.ts","webpack://countries/./src/task2/task2.ts","webpack://countries/./src/task3/task3.ts","webpack://countries/webpack/bootstrap","webpack://countries/webpack/runtime/define property getters","webpack://countries/webpack/runtime/hasOwnProperty shorthand","webpack://countries/webpack/runtime/make namespace object","webpack://countries/./src/index.ts"],"sourcesContent":["import { AppVariables } from '../src/types'\n/*\nobiekt ze zmiennymi uzywanymi w apliakcji\n*/\nexport const appVariables: AppVariables = {\n  API_URL: \"https://restcountries.com/v2/all\",\n  TIME_KEY: \"time\",\n  COUNTRY_KEY: \"countries\",\n  CURRENT_TIME: new Date().getTime(),\n  INTERVAL: 100000,\n  POPULATION_LIMIT: 500000000,\n};","import { LocalStorageMethods, LocalStorage, Countries, } from '../types';\nimport { appVariables} from '../appVariables'\n\nconst { TIME_KEY, COUNTRY_KEY, API_URL, CURRENT_TIME } = appVariables;\n\n/*\nobiekt z metodami localStorage:\ngetData przyjmuje parametr key będący typem string, zwraca stringa lub null.\nsetData przyjmuje parametr key typu string, value typu any i nie zwraca nic.\n*/\nconst localStorageMethods: LocalStorageMethods = {\n  getData: (key) => localStorage.getItem(key),\n  setData: (key, value) => localStorage.setItem(key, JSON.stringify(value))\n};\nconst { getData, setData } = localStorageMethods;\n\n/*\nZmienna pomocnicza countriesInStorage:\nArgumentem w metodzie JSON.parse() musi być zmienna typu string.\n*/\nconst countriesInStorage = getData(COUNTRY_KEY);\n\n/*\nObiekt countriesLocalStorage:\nPrzechowuje dane krajów i czas ich ostatniego pobrania z API.\n*/\nexport const countriesLocalStorage: LocalStorage = {\n  fetchTime: Number(getData(TIME_KEY)),\n  storedCountries: countriesInStorage ? JSON.parse(countriesInStorage) : null\n};\nconst { storedCountries } = countriesLocalStorage;\n\n/*\nFunkcja fetchData:\nPobranie danych z API.\nWewnątrz funkcja comparePopulation.\n*/\nexport const fetchData = () => {\n  fetch(API_URL)\n  .then((res) => res.json())\n  .then((countries) => {\n    console.log('%c * Countries from fetch: ', 'color: #F0CD10', countries)\n\n    const fetchedCountries: Countries[] = countries;\n\n    setData(TIME_KEY, CURRENT_TIME);\n    setData(COUNTRY_KEY, fetchedCountries);\n\n    if (storedCountries) {\n      comparePopulation(fetchedCountries, storedCountries);\n    }\n  })\n  .catch((err) => console.log(err));\n}\n\n/*\nFunkcja comparePopulation:\nPorównuje dane krajów z localStorage i z fetch pod względem zmian populacji. Jezeli w danych z fetch populacja się\nzmieniła, nazwy tych krajów zwracane są w nowej tablicy countriesWithPopulationChange.\n*/\nconst comparePopulation = (currData: Countries[], prevData: Countries[]): string[] => {\n  const countriesWithPopulationChange: string[] = [];\n  for (let i = 0; i < prevData.length; i++) {\n    if (currData[i].population !== prevData[i].population) {\n      countriesWithPopulationChange.push(currData[i].name);\n    }\n  }\n  console.log('%c * Countries with population change:', 'color: #F0CD10', countriesWithPopulationChange);\n  return countriesWithPopulationChange;\n};","import { Countries } from '../types';\nimport { countriesLocalStorage } from '../task1/task1';\nconst { storedCountries } = countriesLocalStorage;\n\n/*\nFunckja countriesFromEU:\nZwraca kraje z regionu EU.\n*/\nexport const countriesFromEU = (countries: Countries[]): Countries[] => {\n  return countries.filter((item) => item.regionalBlocs && item.regionalBlocs[0].acronym === 'EU')\n};\n\n/*\nFiltrowanie zwróconych krajów EU bez litery 'a' w nazwie kraju.\n*/\nexport const euCountriesWithoutLetterA: Countries[] = countriesFromEU(storedCountries)\n.filter((item) => !/a/.test(item.name));\n\n/*\nDalsze sortowanie krajów EU bez 'a' wg liczby populacji.\n*/\nexport const euCountriesSortedByPopulation: Countries[] = euCountriesWithoutLetterA\n.sort((a, b) => b.population - a.population);\n\n/*\nSuma 5 krajów o największej populacji.\n*/\nexport const countriesPopulationSum = (countries: Countries[]): number => {\n  return countries\n  .sort((a, b) => b.population - a.population)\n  .slice(0,5)\n  .map((item) => item.population)\n  .reduce((a, b) => a + b);\n}\nexport const topFiveCountriesPopulationSum = countriesPopulationSum(storedCountries);\n","import { Countries, RegionalBlocs, BlocsObj } from '../types';\nimport { countriesLocalStorage } from '../task1/task1';\nconst { storedCountries } = countriesLocalStorage;\n\n/*\nFunkcja createBlocsObj:\nTworzy obiekt przyjmując jako parametr tablicę stringów objKeys.\nKluczami są wartości tablicy. Dla kazdego klucza przypisuje wartość - tworzy kolejny obiekt.\n*/\nconst blocs: string[] = ['EU', 'AU', 'NAFTA', 'other'];\n\nconst createBlocsObj = (data: string[]): RegionalBlocs | {} => {\n  const obj: RegionalBlocs | {} = {};\n  data.forEach((key) => {\n    obj[key] = {\n      countries: [],\n      currencies: [],\n      languages: {},\n      population: 0\n    }\n  })\n  return obj;\n};\nexport const newBlocsObj: {} = createBlocsObj(blocs);\n\n/*\nFunkcja createRegLangList:\nZwraca tablicę języków (ich kodów iso) dla wybranego regionu. Jako parametr przyjmuje tez nazwę regionu.\nDla other >>> false\n*/\nconst createRegLangList = (countries: Countries[], region: string) => {\n  const iso639_1_langArr: any = [];\n  countries.forEach((country) => {\n    if (country.regionalBlocs && country.languages && country.regionalBlocs.find(item => item.acronym === region)) {\n      const langList = country.languages;\n      iso639_1_langArr.push(langList.map(item => item.iso639_1));\n  }\n  });\n  const isoCodeLangList: [] = iso639_1_langArr.flat();\n  const uniqIsoCodeLangList: string[] = isoCodeLangList.filter((a, b) => isoCodeLangList.indexOf(a) == b)\n  return uniqIsoCodeLangList;\n};\n\n/*\nObiekt blocsObj:\nWartościami kluczy są wywołania funkcji createRegLangList z podaniem nazwy regionu.\n*/\nconst blocsObj: BlocsObj = {\n  NAFTA: createRegLangList(storedCountries, 'NAFTA'),\n  EU: createRegLangList(storedCountries, 'EU'),\n  AU: createRegLangList(storedCountries, 'AU'),\n}\n\n/*\nFunkcja createLangObj:\nTworzy obiekty langObj dla kazdego languages w danym regionie.\n*/\nconst createLangObj = (data: string) => {\n  const langObj = {\n    countries: [],\n    name: '',\n    population: 0,\n    area: 0\n    }\n  return Object.fromEntries(blocsObj[data].map((key: string) => [key, langObj]));\n}\n\n/*\nFunkcja setDataToObjBlocs:\nIteruje po tablicy blocs. Filtrując po countries (storedCountries) porównuje klucz regionName (wartość indexu tablicy) z countries.regionalBlocs.acronym.\nPo spełnieniu warunku pushuje wartości do obiektu newBlocsObj. Pomija 'other' >>> false.\n*/\nexport const setDataToBlocsObj = (countries: Countries[]) => {\n  blocs.forEach((regionName) => countries.filter((country) => {\n    if (country.regionalBlocs && country.regionalBlocs.find((region) => region.acronym === regionName)) {\n      newBlocsObj[regionName].countries.push(country.nativeName);\n      newBlocsObj[regionName].population += country.population;\n      newBlocsObj[regionName].languages = createLangObj(regionName);\n\n      country.currencies.forEach((currency) => {\n        if (!newBlocsObj[regionName].currencies.includes(currency.code)) {\n          newBlocsObj[regionName].currencies.push(currency.code);\n        }\n      }\n    )}\n  }))\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { appVariables } from '../src/appVariables'\nimport { countriesLocalStorage, fetchData } from './task1/task1';\nimport { euCountriesSortedByPopulation, topFiveCountriesPopulationSum, countriesFromEU } from './task2/task2';\nimport { newBlocsObj, setDataToBlocsObj } from './task3/task3';\n\nconst { CURRENT_TIME, INTERVAL, POPULATION_LIMIT } = appVariables;\nconst { fetchTime, storedCountries } = countriesLocalStorage;\n\n/*\nWywołanie funkcji fetchData po spełnieniu warunku.\n*/\n(!storedCountries || fetchTime + INTERVAL <= CURRENT_TIME)\n? fetchData()\n: console.log('%c * Countries from localStorage: ','color: #F0CD10', storedCountries);\n\n/*\nLista krajów EU\n*/\nconsole.log('%c * EU countries: ', 'color: #CDEF32', countriesFromEU(storedCountries));\n\n/*\nFiltrowanie zwróconych krajów EU bez litery 'a' w nazwie kraju.\n*/\nconsole.log('%c * EU countries without letter \"a\" sorted desc: ', 'color: #CDEF32', euCountriesSortedByPopulation);\n\n/*\nSuma 5 krajów o największej populacji.\n*/\n(topFiveCountriesPopulationSum > POPULATION_LIMIT)\n? console.log(`%c * Top Five EU countries without 'a' population sum equals to ${topFiveCountriesPopulationSum} is greater than 500 mln citizens.`, 'color: #CDEF32')\n: console.log(`%c * Top Five countries population sum equals to ${topFiveCountriesPopulationSum} is smaller than 500 mln citizens.`, 'color: #CDEF32')\n\n/*\nUtworzenie obiektu z regionami\n*/\nsetDataToBlocsObj(storedCountries);\nconsole.log('%c * newBlocsObj: ', 'color: #05C6F0' , newBlocsObj);"],"names":[],"sourceRoot":""}