Zadanie 1
Ściągnij wszystkie możliwe dane państw z pomocą API: https://restcountries.com/. W dalszej części kursu będą one nazywane Tablicą Państw (TP).
Ściągnięte dane zapisz w sposób, który pozwoli na ich ponowne wykorzystanie po zamknięciu i ponownym otwarciu przeglądarki,
Przy starcie aplikacji sprawdź, czy dane państw istnieją w pamięci przeglądarki. Jeśli nie, ściągnij je,
Przy starcie aplikacji sprawdź ile czasu minęło od poprzedniego ściągnięcia danych państw. Jeśli od ostatniego razu minęło co najmniej 7 dni, ściągnij i zapisz je ponownie.
Stwórz metodę, która przy ponownym ściąganiu danych państw porówna populację między starym i nowym zestawem danych oraz wyświetli wszystkie nazwy państw, których populacja uległa zmianie.

Kod powinien być w pełni otypowany.
Kod powinien posiadać pełen zestaw testów (Jest).
Kod może posiadać komentarze.

Zadanie 2
Z Tablicy Państw z zadania 1 przefiltruj wszystkie należące do Unii Europejskiej.
Z uzyskanej w ten sposób tablicy usuń wszystkie państwa posiadające w swojej nazwie literę a.
Z uzyskanej w ten sposób tablicy posortuj państwa według populacji, tak by najgęściej zaludnione znajdowały się na górze listy.
Zsumuj populację pięciu najgęściej zaludnionych państw i oblicz, czy jest większa od 500 milionów

Kod powinien być w pełni otypowany.
Kod powinien posiadać pełen zestaw testów (Jest).
Kod może posiadać komentarze.

//TESTY
testy powinny działać w izolacji
beforeEach
rozbić samodzielne jednostki testów
na poczętku test dla istoty obiektu
behavior driven development - testowanie zachowań

console.time, console.timeEnd - patrzymy w konsoli, mierzymy jak szybko działa

//TypeScript

* Typy proste: string, number, boolean
let someVal: string = 'Mike';
* Arrays: number[], string[], są tez generics: T<U> np. Array<number>
let someArr: string[] = ['1', '2', '3']
* typ any: wyłącza type checking. Jezeli chcemy aby typ any był postrzegany jako error => noImplicityAny = true
* funkcje:
- określenie typu parametru funkcji (Parameter Type Annotations)
function someFun(name: string){console.log(name)};
W tym wypadku będzie sprawdzany typ przekazywnych argumentów.
- okreslenie typu zwracanego (Return Type Annotations)
function someFun(): number {return 26}
- funkcje anonimowe
W funkcjach anonimowych (równiez fatArrow) TS automatycznie determinuje typ parametru. Jest to tzw Contextual Typing. Context that the function occurred within informs what type it should have.
const names = ["Alice", "Bob", "Eve"];
names.forEach((s) => {
  console.log(s.toUppercase());
  >>> Property 'toUppercase' does not exist on type 'string'. Did you mean 'toUpperCase'?
});
* Obiekty
Aby zdefinować typ obiektowy podajemy jego właściwości i ich typ:
function printCoord(obj: { x: number; y: number }) {
  console.log("The coordinate's x value is " + obj.x);
  console.log("The coordinate's y value is " + obj.y);
}
printCoord({ x: 3, y: 7 });

Opcjonalne pola obiektu zapisujemy ze znakiem '?'
function printName(obj: {first: string, last?: string}){
  if(!obj.last){
    console.log("Person's first name is " + obj.first);
  } else {
    console.log("Person's full name is " + obj.first + " " + obj.last);
  }
}
printName({ first: "Bob" });
printName({ first: "Alice", last: "Alisson" });

* Union Types
Typy kombinowane, łączone z dwóch lub więcej typów, które reprezentują wartości mogące być kadym z tych łączonych typów.
function printID(id: number | string) {
  console.log("Your ID is: " + id);
}
// OK
printId(101);
// OK
printId("202");
// Error
printId({ myID: 22342 });

* Narrowing
Jezeli mamy typ string | number, nie mozemy uzywać w kodzie metod, które są tylko dla stringów:
function printId(id: number | string) {
  console.log(id.toUpperCase());
Property 'toUpperCase' does not exist on type 'string | number'.
  Property 'toUpperCase' does not exist on type 'number'.
}
W takim wypadku trzeba wprowadzić warunki:
function printId(id: number | string) {
  if (typeof id === "string") {
    // In this branch, id is of type 'string'
    console.log(id.toUpperCase());
  } else {
    // Here, id is of type 'number'
    console.log(id);
  }
}

Wyjątek stanowią podtypy, które mają takie same metody

* type aliases
type Point{
  x: number;
  y: number
};

type ID = number | string;

* interfaces
interface Point{
  x: number;
  y: number;
}

type can't be re-opened to add props, interface can!
Do interfejsu zawsze mozemy dodać kolejne pola.

* Type Assertions
gdy np. uywamy document.getElementById, TS wie jedynie, ze to zwróci jakiś HTMLElement.
mozna zapisać: const myCanvas = document.getElementById("main_cancas") as HTMLCanvasElement.
Mozna zapisać to samo: myCanvas = <HTMLCanvasElement>document.getElementById("main_canvas"); ale nie w plikach .tsx

* Literal Types
let changingString = "Hello World";
changingString = "Olá Mundo";
changingString;
>>> TypeScript hover let changingString: string

const constantString = "Hello World";
constantString;
>>> TypeScript hover const constantString: "Hello World"

Uzycie literal types w union daje mozliwość, ze np. funkcje przyjmują wybrany zestaw znanych wartości:
function printText(s: string, alignment: "left" | "right" | "center") {
  // ...
}
printText("Hello, world", "left"); ok
printText("G'day, mate", "centre"); error

* Literal interface

const obj = { counter: 0 };
if (someCondition) {
  obj.counter = 1;
}

const req = { url: "https://example.com", method: "GET" };
handleRequest(req.url, req.method);
Argument of type 'string' is not assignable to parameter of type '"GET" | "POST"'.
// Change 1:
const req = { url: "https://example.com", method: "GET" as "GET" };
// Change 2
handleRequest(req.url, req.method as "GET");

const req = { url: "https://example.com", method: "GET" } as const;
handleRequest(req.url, req.method);
The as const suffix acts like const but for the type system, ensuring that all properties are assigned the literal type instead of a more general version like string or number.

* null and undefined
strictNullChecks: on
kiedy zmienna ma waertość null lub undefined, trzeba przetestować te wartości aby dalej uzyc metod lub właściwości na tej wartości - narrowing:
function doSomething(x: string | null) {
  if (x === null) {
    // do nothing
  } else {
    console.log("Hello, " + x.toUpperCase());
  }
}

* Non-null Assertion Operator(Postfix !)
Korzystając z ! za wyrazeniem zapewniamy ze wartość nie jest null lub undefined:
function liveDangerously(x?: number | null) {
  // No error
  console.log(x!.toFixed());
}
Uzywać wyłącznie kiedy jesteśmy pewni, ze wartość nie moze być null ani undefined.

* Enums

* Symbol